
## 网络编程
- 此为网络编程总览，tcp/ip 的记录放在tcp/ip中 
- 网络编程一直是一块心病， 实用性很强， 所以， 很想学好， 网络编程是基础! 也为了实用性的兴趣
- web服务器，邮件服务器， 实时通信, 现在的应用少不了网络编程

## 数据传输过程
- 网络通信分有线， 无线, 不管是有线还是无线， 数据最终都到网卡
- 有意思的就是这个数据， 网卡会不会解析所有的数据呢？ 肯定不是，只能是特定频段的数据, 解析所有的数据， 也没有那个能力解析
- 无线传输频率， 有线传输频率， 线缆可以传输几种频段的数据, 无线天线可接收到所有的数据， 但是只对特定频段的数据敏感， 有线网卡可接收到线缆可传输的几种频段的所有数据， 也只针对特定频段的数据解析， 这就是网卡能力， 线缆能力。 经过滤波，调制解调， 解析到特定频段的数据后， 交有操作系统分发

## 客户端， 服务端
- 数据包中带有ip:port
- 不管是客户端还是服务端， 最后数据都是经过操作系统派发
- 服务端的端口监听都是在操作系统注册， 客户端发送数据带端口， 就是调用操作系统打包数据的能力
- 传输过程， 是也并不是传输到每一个路由和终端上， 路由也自带选择路径能力， 会根据数据包中的ip:port选择发送指定路由
- 至此， 网络编程过程中的技术概念已经角色各自归位了
- 服务端与客户端的端口能保持一样吗？ 不能， 这并不会造成端口浪费. 如果客户端和服务端是在同一台主机上，那也是各自的用途， 不在同一主机上，两端口更没有互斥关系 
- 同一台主机上的不同服务可以使用同一个端口吗？ 
    * 应该是不行的， 因为端口管理由操作系统来决定

## java 实现网络编程 
1. tcp, udp
    - 服务端， 客户端, 唯一标识: ip:port
    - 真正简单地实现， 貌似并没有什么难度， 我害怕在哪里呢？ 复杂框架的特性， 当然也是积累在基本的应用上
    - 先实现一款最基本的， 再考虑搭框架的事， 本来也没多少代码， 关键是将原理搞明白
    - 已经实现了基本的服务端， 客户端通信
        服务端: socket, bind, listen, accept, receive, send, 捕捉异常, close
        客户端: socket, connect, send, receive, close
        > 线程阻塞机制是怎么实现的？
        > I/O多线程如何实现?
        > 如何发广播？想实现智能配对， 而不是写死或者手动输入
    - 做成可以实现多客户端拷贝
    - Socket, ServerSocket 的源码分析

        一时间并不能看出个所以然，将bind, listen的流程走完了, 服务端<->客户端手动交互的流程没啥问题
    - tcp 连接主动断开, 如何再连接呢？

        目前不能再复用上一次的连接， 只能创建新的连接
    - SocketException, connection reset 问题解决
        还未解决， 当连接剩最后一个时候会报此问题，按理说也应该是这样的, 与linxu的fork线程是一个思想
    - udp 是以广播的形式连接，但是在解析报文的时候， 需要做的事情就相对多一些。

    tcp, udp编程， 在java上实现， 并没有多大的感受，熟悉了tcp, udp各自的连接过程，其实也没有那么难.
    > tcp 的服务端要麻烦一些，服务端支持多个客户端， 因此有一个专门用来监听连接的端口， 创建连接成功后，在c中是创建一个文件通信的文件描述符， 在java中是创建一个socket的专门用来通信 <br>
    udp 没有明确的服务端和客户端，每个DatagramSocket, 即可以当作服务端， 也可以用来发送数据当作客户端, 发送数据在DatagramPacket中指名 ip:port,  便可达到通信<br>
      按理说， 这样的流程在看图的时候， 也能明白的， 为何只能真正结合代码看到通信效果后， 才算印象更深了呢？
      真正的具体实现， java的源码暂时也没时间看， c的实现还未做， 何谈更底层的实现， 更底层的实现也是对osi 网络模型的协议实现, 所谓的数据传输就是拉高，接低电平， 形成模拟信信号，然后将模拟信号转成数字信号。 网络信息传递过程中， 路由担负着选路的角色。

      tcp的三次握手和四次挥手

2. java 多线程
    - 线程池的使用， 没啥问题， 进一步的控制能力欠缺
    - 如何实现自己的线程池？ 线程保活待命
        线程池做了保活， 而且还有等待的机制，在线程池的所有线程都在工作的情况下， 后续的任务
    - 各种锁的触发条件及解决办法
    - 线程的生命周期控制
    - 线程如何实现sleep的， 如何实现阻塞的
    - timer 坑点
    - HashMap 源码， 实现原理, 为何是以2的幂扩容
    - HashMap, HashTable, ConcurrentHashMap 的区别， 在极高并发下， 哪个性能更好， 如何实现的
    - 动态代理的两种方式， 区别
    - B+树， 八大排序
    - 一致性Hash算法
    - Lock 接口有哪些实现类， 使用场景是什么 
    - 可重入锁， 用处及实现原理, 写时复制过程， 读写锁， 分段锁(ConncurrentHashMap中的segment)
    - 悲观锁， 乐观锁, CAS有什么缺陷
    - 多个线程如何保证有序执行
    - ThreadLocal 实现原理
    - CountDownLaunch, CyclicBarrier 异同点
    - JMM中原子操作

3. java nio
    - 阻塞I/O
    - 非阻塞I/O

- jvm 
    - 逃逸分析技术
    - 双亲委派模型的过程及优势

## blog
### 学到了什么？
1. tcp/ip 基础
    目前主流的网络编程都是以tcp/ip协议为主流的， 当然还有其他的通信协议

    tcp/ip 概念： 书， 网络通信模型
    - 对于书而言， tcp/ip 讲解得是基于整个网络通信模型而言， 从底层到上层应用的协议族
    - 对于通信模型，tcp层, ip层是不同的层级, 为何单独将这两层提出来呢？

2. 网络通信模型

    (物理层), 链路层，网络层， 传输层， (会话层， 表示层), 应用层

3. 网络编程高级应用， 必然与多线程的知识绑定

    之前总是因为多线程的知识，卡在网络编程的学习上, 这样的学习效率必然低下， 但是目前也没有更好的办法去改善，先跳过一些知识的学习， 肯定在学习过程中也是一直应用的，只不过对于有些知识就是跳不过去 

4. 什么是网络编程？

    为了实现端到端的通信, 抽象出了网络通信模型，网络编程即是实现每一层通信模型以及每一层通信模型上所遇到的问题。<br>
    物理层，电缆，无线电， 光纤 <br>
    链路层, 以太网，令牌环网，HDLC, 帧中继，ISDN，ATM， IEEE 802.11， FDDI， PPP, 链路层的不同协议表示不同的网络， tcp/ip 对应以太网， 其他的网络自由其应用场景 <br>
    网络层, IP(网际协议), ICMP(Internet互联网控制报文协议), IGMP(Internet组管理协议), IPX, BGP, OSPF, RIP, IGRP, ARP, RARP, X.25, 对于tcp/ip协议族而言，所有的路由器必须实现IP， ICMP <br>
    传输层, tcp, udp, RTP, SCTP, SPX, ATP, IL, <br>
    会话层，ASAP, ISO 8327/CCITT X.255, RPC, NetBIOS, ASP, IGMP, Winsock, BSD sockets <br>
    表示层，XDR， ASN.1, SMB, AFP, NCP <br>
    应用层, ftp, telnet, smtp(邮件传输协议), snmp(网络管理协议) <br>
    而通用的程序员, 网络编程是指基于具体业务，在应用层面实现一些自己的应用

5. 实际应用层的网络编程中，会遇到哪些问题呢？
    - 可靠性
    - 效率
    - 解析与打包的效率
    - 高并发
    - 业务逻辑的完善性

### 还有哪些方向知道, 但是还不会的？
1. web server 简单的原理是懂了， 那么是如何应用到企业级的呢？ 
    - 为何会有那么多配置, 且各个文件夹都有不同的用处
    - Servelet 技术， 是不是也是动态加载自定义的类呢？ 不是的， 不过是基于spring开放出来的接口

2. 基于现有的思想， 看一看成熟的服务器源码
    - skynet 
    - 

### 以什么形式来表现确实学会了？
对于使用java， 编写一个基本的c/s 结构的demo， 按照他人的blog, 也就1个小时可以看到效果， 所以， 我急个什么呢？ 看会了这些基本的， 一步步实现， 高楼大厦自然而然就起来了

写一个支持多客户端通信的框架, 达到敢于应用在公司项目里， 预计可以锻炼的能力：
- 内存管理， 尽量少的内存回收
- 多线程编程
- 易于扩展， 在此基础上写一个web服务器呢? 
