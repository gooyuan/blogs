## 多线程
1. 核心点
- 数据一致性
- 互斥, 锁
- 内存消耗
- 什么是真正的高并发编程
    * 实际应用场景
    * 真正能提升效率
- 

2. 理解

    语言无关, 思想共通

    并发操作是不可必免的， 不管是单核还是多核，为了合理利用cpu资源， 用户交互体验 

    进程是系统资源分配的最小单位， 线程是系统分派和调度的最小单位

    进程的状态， 就绪状态(退出阻塞态， 并未获取到CPU时间片)， 执行态(获取到CPU时间片)， 阻塞态(被I/O操作中断)

    - cpu资源该如何分配， 就引出了线程调度的话题 
        抢占式， 非抢占式
        调度策略设计参数： 响应时间 ， 周转时间， 平均周转时间 
        调度算法: 
            FCFS(先来后到排序) 
            SJF(最短的作业最先调度, 可以保证最小平均等待时间) 
            HRN(最高响应比优先法, FCFC, SJF的结合), 
            优先权调度(会出现饥饿现象)， 
            Round-Robin(RR, 设置一个时间片， 轮流来， 时间短上下文切换频繁， 时间长，退化成FCFS)
            多级队列调度， 多级反馈队列

    并发会存在同一时刻访问共享资源问题，共享资源可以是内存变量， 也可以是打印机， 对这块的研究可以使用`**图`来分析, 

    - 临界资源与临界区

        进入区，临界区， 退出区， 剩余区 

    方法

        软件方法， 关中断方法， 硬件原子指令方法， 信号量(s,q), 信号量和等待队列

    锁

        互斥锁， 自旋锁，乐观锁， 悲观锁， 读写锁, 阻塞锁， 可重入锁， 公平锁， 非公平锁 

    - 进程间通信

        消息传递， 同步， 共享内存， 远程过程调用
    - 线程

        内核线程， 用户线程
    - IO多路复用

3. java 多线程
    - ScheduledThreadPoolExecutor
        不是线程池发生异常会停止， 而是ScheduleThreadPoolExecutor, 发生异常就会中止计时
    - recyclerview 没那么简单, 卡得很, ListView 还有其用武之地, 越复杂越容易出问题
    - 线程池的使用， 没啥问题， 进一步的控制能力欠缺
        线程池如果有一个线程抛出异常， 其他的线程并不会影响，但是在android 中如果没有处理这个异常，app 就会崩溃, 想进一步精细控制线程就不OK了
    - 如何实现自己的线程池？ 线程保活待命
        线程池做了保活， 而且还有等待的机制，在线程池的所有线程都在工作的情况下， 后续的任务
    - 各种锁的触发条件及解决办法
        ReentrantLock, 目前也就发现了一个可重入锁
    - 线程的生命周期控制
        创建，运行，等待阻塞，中止, 结束
        interrupt 并不会停止线程，只是对interrupt标志位处理，需要线程自身配合是否停止线程 而且在中断过程中如果线程处理wait(), join(), slee() 抛出异常并清理中断状态， select(), blocking in I/O channel 抛出异常, 关闭channel，并设置为中断状态
    - 线程如何实现sleep的， 如何实现阻塞的
        sleep, wait, 都是native级别， 这里需要研究操作系统的实现， 实现阻塞就是while(ture) + wait() 组合， 即可以保证线程不死， 也可以让出cpu 的时间片
    - timer 坑点
        目前使用并没有发现什么坑点， 容易内存泄露？
        对系统时间比较敏感， 也容易出现执行一会就挂死的现象, ScheduledThreadPoolExecutor 也同样会出现， 包括使用线程结合Thread.sleep(), 仔细想想也是，应该都是开一个线程来实现的， 如果有异常，没有做异常处理， 线程肯定要挂掉， 这个又是虚拟机层面的处理
    - HashMap 源码， 实现原理, 为何是以2的幂扩容
    - HashMap, HashTable, ConcurrentHashMap 的区别， 在极高并发下， 哪个性能更好， 如何实现的
    - 动态代理的两种方式， 区别
        代理存在的意义？ 
    - B+树， 八大排序

    - 一致性Hash算法

    - Lock 接口有哪些实现类， 使用场景是什么 
        ReentrantLock
    - 可重入锁， 用处及实现原理, 写时复制过程， 读写锁， 分段锁(ConncurrentHashMap中的segment)

    - 悲观锁， 乐观锁, CAS有什么缺陷

    - 多个线程如何保证有序执行

        在共享数据源头加锁，可以保证数据是依次使用的
        如何让线程1打印1, 线程2打印2呢？两个线程好控制， 多个线程使用线程池也不容易控制了， 需要使用Thread 单独实现, 而且还需要分先后顺序依次启动
        wait() 让线程进入等待， 失去锁, 不再占用cpu时间片, 所以， 维护自己的线程池， 也需要while(true) + wait() 来等待 
        nofity() 是针对具体的对象notify, 所以synchronized() 的参数必须是一个对象，才会有nofity, wait() 方法,  对于obj 的选择， 也封装了Condition类，使代码更容易阅读

    - ThreadLocal 实现原理

    - CountDownLaunch, CyclicBarrier 异同点

    - JVM中原子操作

3. java nio
    - 阻塞I/O
    - 非阻塞I/O
        channel, selector

- jvm 
    - 逃逸分析技术
    - 双亲委派模型的过程及优势


4. Java concurrency in practice

    与其这一点，那一点的看， 不如看一看java 并的的圣经

    带着问题看， 就是要预习， 预习肯定有那么多不知道的， 这些就是问题。
    到现在， 也看了一些多线程的知识， 适当总结一下， 已知和未知

    - 基础的多线程编程已经没啥问题， 内存模型当然很重要， 主线程， 工作线程
    - 什么是自旋， 自旋锁

5. 深入理解java虚拟机

    jvm 也是时候学习一下了， 有了csapp的经验， 这个应该会比较快


