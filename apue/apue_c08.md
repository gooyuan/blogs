
## 第八章 进程控制

### 学习记录

fork 函数也没有那么神秘, 可以直接调用, 本来就是嘛, 站在不同的层次, 做不同的事, 每个角色, 都是整个系统的一部分, 没必要特殊对待, 尽管是轻重之分.

最开始的印象真得影响很大, 最开始觉得难, 后续再次捡起来学的时候, 最开始的那种恐惧感还会影响到下意识, 下意识是畏难的.

士别三日将刮目相看, 这一道理不管是对别人, 还是对自己, 都是适用的, 训练降低第一印象的影响. 
我也已非吴下阿蒙, 所以, 学习的方式该有所改变, 也要时刻去提炼, 哪些是精华, 哪些是可以改进的. 

在linux内核情景分析看到的关于fork函数, 当时的感觉, 这是内核层的东西, 算是高级技术, 所以是难的, 轻易接触不到的, 那是因为站在的平台不一样, 这些最底层的抽象度可能高些, 但也不是高不可攀, 站在巨人的肩膀上, 肩膀以下只是少走了弯路, 同样也学会. 

fork 

	返回两次, 父进程与子进程是并行运行的, 公共部分的代码是两个进程共同操控的, 但是变量值各自保持一份
	每fork一次, 进程增加一个, 这样来编写多线程是挺绕的. 

wait, waitpid

	wait 是个阻塞的函数, 所谓的阻塞, 就是过程实现, 汇编实现, 是将sip 指向子进程的代码, 执行完了再返回. 

竞争条件

	在多进程/线程访问共享数据或输出结果依赖于进程执行顺序时, 会产生竞争条件

exec 函数

	执行一个新函数只是替换了当前进程中的正文段, 数据段, 堆段和栈段.

修改用户id, 组id

	设置用户ID(set-user-ID), 有效用户ID(effective user ID), 实际用户id, uid, gid

	这几个概念, 当前登陆用户, 操作文件, 当前进程 都有 uid, gid, 

	login 时, 设置登陆用户的uid, gid, 称作实际用户id

	每个文件都有所有者, 这个所有者的id 与 文件设置位 共同决定进程操作文件时的有效id

	每个进程的id叫作有效id, 一般情况下是与实际id一致, 但是或文件的设置位打开时, exec打开程序会将有效id设置为程序文件所有者id, 达到临时提权的效果, 这也是passwd 程序可以改变系统passwd文件的机制. 
	root可以操作所有文件, 但是同可以设置文件的读写, 可执行位, 来保护文件, 如果root对于一个非w的文件写操作时, 也得先修改其w位.
	execve是内核程序, 有root权限. 

	一个文件的每个属性的每个位置含义
	drwxrwxrwx
	第一个属性 
		d : 目录, 
		`-` : 文件, 
		l : 链接, 
		b : 可随机存取装置, 
		c : 串行端口设备
		s : 数据接口文件
		p : 管道文件

	后面每三个一组, 第一组 代表所有者的读写可执行权限, 第二组代表所有组的读写可执行权限, 第三个代表其他用户的可操作权限. 
	每组第三位
		w : 可执行
		s : 可设置, 通过exec 执行时, 会将当前进程的有效id临时提权到程序文件所有者的id. 执行完恢复成实际用户的id, 只能应用在可执行程序文件上
		t : 粘滞位, 在程序执行完时, 告诉系统在内存(虚拟内存,非物理内存) 中保存一份备份, 常用的程序可以节省寻址时间, 只对目录有效, 该属性设置后, 只有目录所有者及root才可以删除此目录. 

解释器文件

```sh
	#! pathname [optional-argument]
```

	解释器文件是第一行以`#!`开头的文本文件, 解释器是`#!`后面绝对路径指向的可执行文件
	exec在执行解释器文件时, 会解析其解释器来执行此文件

system 

	可以通过sh -c 来将字符串解析成命令执行

进程会计
	
	对进程信息的统计

### 总结

### 习题与问题
1. 在图8-3程序中, 如果用exit调用代替_exit 调用, 那么可能会使标准输出关闭, 使printf 返回-1. 修改该程序以验证在你所使用的系统上是否会产生此种结果. 如果并非如此, 你怎样处理才能得到类似的结果呢? 

2. 回忆图7-6中典型的存储空间布局. 由于对应于每个函数调用的栈帧通常存储在栈中, 并且由于调用vfork后, 子进程运行在父进程的地址空间中,如果不是在main函数中而是在另一个函数中调用vfork, 此后子进程又从该函数返回, 将会发生什么? 请编写一段测试程序对此进行验证, 并且画图说明发生了什么? 

3. 重写8-6中的程序, 把wait 换成waiteid. 不调用pr_exit, 而从siginfo 结构中确定等价的信息. 

4. 当用$./a.out执行图8-13中的程序一次时, 其输出是正确的. 但是若将该程序按下列方式执行多次, 则其输出不正确. 
```shell
$ ./a.out; a.out; ./a.out
output from parent
ooutput from parent
ouotuptut from child
put from parent
output from child
utput form child 
```
原因是什么? 怎样才能更正此类错误? 如果使子进程首先输出, 还会发生此问题吗?

5. 在图8-20所示的程序中, 调用execl, 指定pathname为解释器文件. 如果将其改为调用execlp, 指定testinterp 的filename, 并且如果目录/home/sar/bin 是路径前缀, 则运行该程序时, argv[2] 的打印输出是什么?

6. 编写一段程序创建一个僵死进程, 然后调用system执行ps(1)命令以验证该进程是僵死进程.

7. 8.10 节中提及POSIX.1 要求在exec时关闭打开目录流. 按下列方法对此进行验证: 对根目录调用opendir, 查看在你系统上实现的DIR结构, 然后打印执行时关闭标志. 接着打开同一目录读并执行时关闭标志. 
