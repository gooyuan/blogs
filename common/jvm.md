
## jvm

    内存模型
    类加载机制
    jvm 性能调优
    字节码
    内存回收

    我所理解的虚拟机: 适配了在各种系统上的系统函数， 将这些工作由一个有实力的公司统一做一遍， 然后实现代码共享。虚拟机的机器码对应字节码，jdk 实现对应的jre库
    跳出来看， 一个虚拟机开启一个进程，虚拟机初始化的过程即是加载jre的过程， 后面的再加载类的时候，根据字节码再转换成对应系统的机器码  
    内存回收有几种策略
    常用的性能调优方案
    字节码， 内存模型， 现在已不是认知问题
    类加载机制， 真得看下源码？ 类加载到虚拟机， 要做些什么工作

## 深入理解java虚拟机:JVM高级特性与最佳实践
1. 走近java
    - java背景，发展史， 未来发展方向
    - 自编译jdk, java develop kit, java 语言, api, 虚拟机, java se 与虚拟机统称为 jre

2. 自动内存管理
    - 方法区，堆， 虚拟机栈， 本地方法栈， 程序计数器, 执行引擎， 本地库接口
    - 分代年龄, 偏向锁，
    - OOM, Stack OOM, Perm OOM
    - jhat, 引用与直接地址
    - Garbage Collection

        引用计数器
        可达性
        强引用，软引用， 弱引用， 虚引用
        finalize 是对C/C++ 程序员的一种妥协， 历史遗留问题
        标记清理， 标记整理， 分代收集， 复制算法
        枚举根节点， 安全点, 安全区域
        Stop-The-World
        最短回收停顿时间
        浮动垃圾
        Serial, Serial Old, ParNew, Parallel scavenge, parallel old, cms, g1
    - 虚拟机性能监控与故障处理工具

        jstat, jstack, jhat, jps, jinfo, jmap, jconsole, visualvm
    - 调优案例分析与实战

        高性能硬件上的程序部署策略
            1. 选用64位jdk使用更大内存
            2. 部署多个32位虚拟机，构建集群，在前端搭一个负载均衡
        集群间同步导致的内存溢出
            登陆信息需要同步到集群， 保证用户在同一段时间内不能重复登陆， 这个时候如果同步信息可能发生重发较多, 而且在每次登陆可能就需要发送十几或数十次
        堆外内存导致的溢出错误, 有哪些堆外内存呢？
            jni是调用本地库
            虚拟机运行和GC
            线程分配堆栈
            Socket缓冲区
            Direct Memory
        外部命令导致系统缓慢
            通过Runtime.getRuntime().exec() 执行shell命令， 虚拟机首先会克隆一个进程拥有和当前虚拟机同样的变量， 然后再执行shell命令， 最后再退出这个进程。 所以这是一个创建进程和销毁进程的操作, 当然比较消耗系统资源
        服务器jvm进程崩溃
            产生hs_err_pid###.lgo, 在android studio 编译的时候就会经验出现这个错误
        不恰当的数据结构导致内存占用过大
            eden, survivor, 新生代，老年代(tenured), 永久代(PermGen)
            HashMap 的内存使用率才为 16/80 = 18%

3. 虚拟机执行子系统
    - 类文件结构
        * attribute, field, property, variable

            attribute 在xml有有描述标签量, 在字节码里又描述的类似于annotation?
            field 类的成员变量， 除非有特殊说明，否则是指非静态
            property 有set方法的
            variable 常量，本地变量，成员变量
            总体来说, 就相当于一个协议文件， class文件就是按协议紧密排列的二进制流，类加载就是解析class文件, 转换成可执行的命令, 这里面涉及到了各种数据与运算

        * 字节码
            并不是每一条指令码就对应一条机器码， 整体jvm的指令不超过255个，也不要求对齐 

    - 虚拟机类加载机制
        * 加载时机: 加载， 验证， 准备， 解析， 初始化， 使用， 卸载
        * 方法区， 变量， 静态方法，变量
        * 类加载器与全限定名共同确定一个类在jvm 中的唯一性
        * 双亲委派机制正是为了保证类的加载唯一性

    - 虚拟机字节码执行引擎
        * 静态多分派， 动态单分派
        * 动态类型语， 类型的检查的主体过程是在运行期而不是编译期
        * 基于栈的指令集与基于寄存器的指令集

    - 类加载及执行子系统的案例与实战
        * 服务器得保证可以部署不同的服务, 而不同的服务可以引用同一个类库， 所以得保证加载不同的对象
        *

4. 程序编译与代码优化
    - 前端编译， 后端编译
    - 静态编译成字节码与jit编译成目标代码的过程相当于c/c++的编译过程

5. 高效并发
    - 内存模型
        * 主内存，工作内存, lock, unlock, read, load, use, assign, store, write
        * 先行发生原则, 时间先后顺序与先行发生原则基本没有太大的关系
    - 线程
        * 创建，运行， 无限期等待， 限期等待， 阻塞， 终止
        * 绝对线程安全， 相对线程安全
    - 线程安全与锁优化
        * 从思想上分类, 乐观锁与悲观锁
        * 从方式上分类，互斥锁与自旋锁, 互斥锁是悲观锁的一种， 自旋锁是乐观锁的一种
        * 从优化方式上

            自适应自旋
            锁消除
            锁粗化
            轻量级锁
            偏向锁

## summarize

    就这样也算看完了java 虚拟机技术, 有什么收获呢？
    自动内存管理，分代管理, 垃圾回收机制
    Class文件， 也是一个协议解析的问题
    类加载机制， 真正的唯一性是类加载器与全限定名共同决定
    内存模型，常量方法区，堆，虚拟机栈， 本地方法栈， 程序计数器，执行引擎， 本地栈接口
    jdk 的性能调优工具, 截转存文件分析, 虚拟机的一些参数配置
    虚拟机的最大内在受限于主内存，虚拟机的内存不包括执行引擎，自身运行内存，本地栈接口，所以最大内存需要考虑去掉这些开销
    静态编译与jit即时编译
    
