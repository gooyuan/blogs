
## jvm

    内存模型
    类加载机制
    jvm 性能调优
    字节码
    内存回收

    我所理解的虚拟机: 适配了在各种系统上的系统函数， 将这些工作由一个有实力的公司统一做一遍， 然后实现代码共享。虚拟机的机器码对应字节码，jdk 实现对应的jre库
    跳出来看， 一个虚拟机开启一个进程，虚拟机初始化的过程即是加载jre的过程， 后面的再加载类的时候，根据字节码再转换成对应系统的机器码  
    内存回收有几种策略
    常用的性能调优方案
    字节码， 内存模型， 现在已不是认知问题
    类加载机制， 真得看下源码？ 类加载到虚拟机， 要做些什么工作

## 深入理解java虚拟机:JVM高级特性与最佳实践
1. 走近java
    - java背景，发展史， 未来发展方向
    - 自编译jdk, java develop kit, java 语言, api, 虚拟机, java se 与虚拟机统称为 jre

2. 自动内存管理
    - 方法区，堆， 虚拟机栈， 本地方法栈， 程序计数器, 执行引擎， 本地库接口
    - 分代年龄, 偏向锁，
    - OOM, Stack OOM, Perm OOM
    - jhat, 引用与直接地址
    - Garbage Collection

        引用计数器
        可达性
        强引用，软引用， 弱引用， 虚引用
        finalize 是对C/C++ 程序员的一种妥协， 历史遗留问题
        标记清理， 标记整理， 分代收集， 复制算法
        枚举根节点， 安全点, 安全区域
        Stop-The-World
        最短回收停顿时间
        浮动垃圾
        Serial, Serial Old, ParNew, Parallel scavenge, parallel old, cms, g1
    - 虚拟机性能监控与故障处理工具

        jstat, jstack, jhat, jps, jinfo, jmap, jconsole, visualvm
    - 调优案例分析与实战

        高性能硬件上的程序部署策略
            1. 选用64位jdk使用更大内存
            2. 部署多个32位虚拟机，构建集群，在前端搭一个负载均衡
        集群间同步导致的内存溢出
            登陆信息需要同步到集群， 保证用户在同一段时间内不能重复登陆， 这个时候如果同步信息可能发生重发较多, 而且在每次登陆可能就需要发送十几或数十次
        堆外内存导致的溢出错误, 有哪些堆外内存呢？
            jni是调用本地库
            虚拟机运行和GC
            线程分配堆栈
            Socket缓冲区
            Direct Memory
        外部命令导致系统缓慢
            通过Runtime.getRuntime().exec() 执行shell命令， 虚拟机首先会克隆一个进程拥有和当前虚拟机同样的变量， 然后再执行shell命令， 最后再退出这个进程。 所以这是一个创建进程和销毁进程的操作, 当然比较消耗系统资源
        服务器jvm进程崩溃
            产生hs_err_pid###.lgo, 在android studio 编译的时候就会经验出现这个错误
        不恰当的数据结构导致内存占用过大
            eden, survivor, 新生代，老年代(tenured), 永久代(PermGen)
            HashMap 的内存使用率才为 16/80 = 18%


3. 虚拟机执行子系统
    - 类文件结构
        * attribute, field, property, variable

            attribute 模糊的描述， 在xml有有描述标签量
            field 类的成员变量， 除非有特殊说明，否则是指非静态
            property 有set方法的
            variable 常量，本地变量，成员变量
    - 虚拟机类加载机制
    - 虚拟机字节码执行引擎
    - 类加载及执行子系统的案例与实战

4. 程序编译与代码优化
    - 

5. 高效并发
    - 
