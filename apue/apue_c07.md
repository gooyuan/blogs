
## 第七章 进程环境

### 学习记录

main 函数 

	c程序总是从main函数开始执行的. 由内核函数 exec(main(argc, argv));

进程终止
	
	正常终止
	exit, _exit, _Exit, pthread_exit, 带下划线的是直接返回内核, exit 会先调用所有终止程序, 关闭i/o, 再调用_exit, _Exit
	一个进程最多注册32个终止程序

	异常终止
	abort, 信号, 最后一个线程对取消请求做出响应. 

命令行参数

	命令(可执行程序)本身是第0个参数

环境表
	
	环境表是一个数组, 首地址为指针 environ
	数组里的每个元素为 完整的字符串地址. 

	环境表的修改与增加比较麻烦, 已分配的地址是不可更改的, 涉及到内存的分配与移动. 

C程序的空间布局

	正文段, 初始化数据段, 未初始化数据段, 栈, 堆

	正文段是只读, 可共享的, 在内存中只有一个副本; 
	初始化数据段存放所有函数外的变量初始化声明;
	未初始化数据段(bbs, block started by symbol), 存放函数外变量未初始化声明, 执行前, 内核将此段数据初始化为0或空指针. 

	在内存扩展方向为: 低 -> 高, 栈一般从内存的最高地址开始向低地址扩展, 堆从分配完正文段, 初始化数据段, 未初始化数据段的内容后的地址开始向高地址扩展. 
	这样的设计, 可以使栈和堆之间未用的虚地址空间很大. 

	符号表段, 包含调试信息的段, 包含动态共享库链接表的段等, 并不装载到进程执行的程序映像中. 那么它们放在哪里呢? 

共享库

	不带共享库的编译指令 添加 -static参数, 会比使用共享为编译的可执行程序大得多. 

内存分配

	malloc, 分配的空间值不确定,
	calloc, 分配的空间每一位bit值都为0,
	realloc, 新增的空间值不确定. 

	free, 释放所分配的空间. 

	sbrk 是个什么函数? 有何作用. 

环境变量

```c
#include <stdlib.h>

char *getenv(const char *name); // 访问环境变量通过此函数, 不建议直接访问 *environ

// 直接将 name=value 字符串放到环境表中. 若name已存在, 删除原来的定义. 
int putenv(char *str);			

// 没有当前环境变量 name 时, 会怎么样? 有当前name时, rewrite 为非0 , 会删除原有定义, 为零不删除, 值也不会替换, 也不会报错
// 必须得分配空间
int setEnv(const char *name, const char *value, int rewrite); 

int unsetenv(const char *name); // 不会报错
```

setjmp 和 longjmp

	goto 是函数内部的跳转

	setjmp 和 longjmp 是进程内跳转
	
	setjmp 设置跳转点
	longjmp 触发跳转

	自动变量, 寄存器变量, 易失变量, 全局变量, 静态变量
	
	自动变量和寄存器变量 会受编译器优化影响, 恢复到跳转前的值,
	全局变量, 静态变量, 易失变量不受影响, 是最近呈现的值. 

	自动变量不可以赋值到其作用域外的指针. 

getrlimit 和 setrlimit

	每个进程的资源限制, 通过这两个函数读取和设置. 

	软限制值, 硬限制值, 
	软限制值必须小于当前硬限制值, 硬限制值必须有超级权限才可更改, 且值大于当前软限制值. 

### 总结

本章讲解了进程环境的一些概念, 对内存布局的概念更清晰了一些, 这些都是虚拟抽象出来的, 映射到物理内存上是通过MMU模块(软件和硬件共同管理的), 这是虚拟内存技术, 可以统一进程对内存的管理. 

一切都是抽象的, excellent

### 习题与问题

1. 在Intel X86 系统上, 使用Linux, 如果执行一个输出"hello, world" 的程序但不调用exit 或 return, 则程序的返回代码为13(用shell检查), 解释其原因. 

2. 图7-3中的printf 函♳的结果何时才被真正输出? 

3. 是否有方法不使用(a) 参数传递, (b)全局变量这两种方法, 将main中的参数argc 和 argv 传递给它所调用的其他函数? 

4. 在有些Unix 系统实现中执行程序时访问不到其数据段的0单元, 这是一种有意的安排, 为什么?

5. 用C语言的typedef为终止程序定义了一个新的数据类型Exitfunc, 使用该类型修改atexit的原型.

6. 如果用calloc分配一个long型的数组, 数组的初使值是否为0? 如果使用calloc分配一个指针数组, 数组的初始值是否为空指针?

	值都为0

7. 在7.6节结尾处size命令的输出结果中, 为什么没有给出堆和栈的大小?

8. 为什么7.7节中两个文件的大小(879443 和 8378) 不等于它们各自文本和数据大小的和?

	因为还记录了其他的信息, 如地址信息

9. 为什么7.7节中对于一个简单的程序, 使用共享库以后其可执行文件的大小变化如此之大? 

	因为简单程序中引用了标准库 stdlib

10. 在7.10节中已经说明了为何不能将一个指针返回给一个自动变量, 下面的程序是否正确?

```c
int f1(int val){
	int		num = 0;
	int		*ptr = &name;
	if (val == 0){
		int val;
		val = 5;
		ptr = &val;
	}
	return (*ptr + 1);
}
```

	自动变量指得是栈变量, 程序执行完会自动回收
	程序是正确的, 指针也是局部的, 使用完也会自动释放, 返回的是一个值
