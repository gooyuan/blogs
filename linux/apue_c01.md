
## 第一章 Unix基础知识

### 学习记录

快速浏览了一遍, 先简短写下对于每小节所学, 然后再根据记录复盘一遍

Unix 体系架构: 

	内核, shell, 系统函数库与调用接口, 上层应用. 

	内核负责内存管理, 硬件驱动, 进程,线程调度. 

	shell 可以调用程序, 有7个exec 变种. shell也提供与内核交互的能力. 

	shell有不同的版本, 支持的脚本语言也不尽相同. 

	上层应用与内核打交道, 可能通过系统调用, 也可以直接通过系统函数库. 

进入linux:
	
	用户管理, 密码管理. 工作目录, 起始目录(从口令文件中相应用户登陆项中得到)

文件和目录:

	在linux下一切皆文件, 文件和目录信息, 如何查看, 文件树
	文件权限管理. 文件名限制
	使用查看目录下所有文件的程序示例, 介绍了 ls(l) 命令的基本实现

输入和输出:
	
	输入和输出也是文件描述符. 
	每打开一个进程, 会打开2个文件描述符, STDIN_FILENO, STDOUT_FILENO
	都可以重定向, 结合管道运用. 

程序和进程:

	内核通过exec打开一个程序, exec有7个变种.
	每打开一个程序就是一个进程, 每个进程有唯一的pid, 可以通过pid 也控制进程, 中止标志, ctrl + c 或 delete 
	进程下面还有线程, 每个线程也有pid 是相对于进程的, 对其他进程无效. 可以通过线程pid 来管理线程, 所有线程都共享内存空间, 所以访问同一块内存空间的时候, 要注意同步操作, 可以利用多处理器并发处理的能力, 进行多线程编程. 
	进程控制主要函数: fork, exec, waitpid
	程序示例展示了shell的基本实现. 
	
出错处理: 

	内核环境全局有一个errno 字段, 可以通过 strerro 函数将 errno 转成字符串信息, perror 基于errno 在标准错误上产生一条出错消息. 

	处理有三种方式, 忽略, 中断程序, 函数调用. 

用户标识:

	uid, gid, sgid, 用户管理


信号:
	
	linux可以通过信号来通知进程发生了什么情况, 与错误处理方式类同
	kill 命令

时间值:

	有cpu 相对于UTC格林尼治的日历时间, 
	进程时间(滴嗒为单位, 每秒可取50, 60, 100 时钟滴嗒): 
		时钟时间, 进程运行时间总量
		用户时间, 执行用户指令所用的时间量
		系统时间, 该进程执行内核程序所用的时间

系统调用与库函数:

	本质有区别, 实现方式不同, 但是相对于用户来说, 可以不必关心具体的实现方式. 

	系统调用是不可更改的, 功能更简单纯粹, 直接与内核打交道
	系统函数库 是可替换的, 根据不同的场景, 采取不同的实现, 可以调用系统调用, 也可以直接与内核打交道. 

### 总结

第一章基础介绍很好. 快速熟悉后续开发的一些概念与技术. 

总体一看, unix编程的重头戏本就在 文件操作, 多线程编程, 文件I/O, 高级I/O, 网络编程(基于I/O, 多线程)

至于系统数据文件和信息, 信号, 进程间通信, 终端, 数据库, 函数库, 这些就是上述知识系统内核的实现. 

### 习题与问题

1. 在系统上验证, 除根目录外, 目录.和..是不同的.

可以通过 ls -la 查看, stat, fstat 查看文件/目录信息

2. 分析图1-6程序的输出, 说明进程ID为852 和 853 的进程发生了什么情况?

每当通过shell 调用此程序时, 都会新开启一个进程, 执行完就中止进程

3. 在1.7 节中, perror 的参数是用 ISO C 的属性 const 定义的, 而 strerror 的整型参数没有用此属性定义, 为什么?

char *strerror(int errnum);
参数是整型, c 程序是按值传递所有参数, 程序改变不了错误参数值, 没有使用const 的必要

void perror(const char *msg);

参数是指针, 防止程序改变msg 的指向的字符串, 使用const 限定

4. 若日历时间存放在带符号的32位整型数中, 那么到哪一年它将溢出? 可以用什么方法扩展溢出浮点数? 采用的策略是否与现有的应用相兼容?

2^31 - utc 然后换算成时间

定义为64位整型. 

5. 若进程时间存放在带符号的32位整数中, 而且每秒为100时钟滴答, 那么经过多少天后该时间将会溢出? 

2^31 / 100 / 3600 / 24 = 248 天
 
