
## 深入理解计算机操作系统

    Computer Systems - A Programmer's Perspective 
    是时候走一遍了, 有些细节先不深究, 如 float数据, 补码之类
    按顺序读, 太难的, 也先过... 如 处理器体系结构
    主要有个整体的概念, 然后捡感兴趣的章节先读
    优化程序性能, 虚拟内存, 异常控制流, 系统级I/O, 网络编程, 并发编程

## 1. 计算机系统漫游
####  位+上下文
1. 文本文件 和 二进制文件 
2. 上下文, 现在看来没啥疑问, 当初可是怎么都想不明白
3. 看不懂的书, 肯定是积累不够

####  程序
1. 翻译成各种形式的字节码
    > 预处理器 -> 编译器 -> 汇编器 -> 链接器
2. GNU环境 
    * EMACS编辑器, GCC编译器, GDB调试器, 汇编器, 链接器, 处理二进制文件的工具及其他一些部件
    * free
####  编译系统
1. 编译器是如何将代码转换成不同平台的机器语言
2. 优化程序性能
3. 理解链接时出现的错误
4. 避免安全漏洞

####  处理器解释指令 
1. shell 解释可执行程序
2. 系统的硬件组成
- 总线
    * 电子管道
- I/O设备
    * 每个I/O设备都通过一个控制器和适配器与I/O总线相连
    * 控制器和适配器的区别主要在于它们的封装方式
- 主存
    * DRAM (dynamic random access memory)
    * 即内存, 临时存储

- 处理器
    * 核心是一个大小为一个字的存储设备, 程序计数器(PC), 指向主存中的机器指令
    * 指令集架构, 微体系结构
    * 寄存器文件是啥, 存放几百字节, CPU 和 ALU各16个? 跟这还不一样, 专门设计的SRAM, 寄存器堆, 
####  高速缓存
1. 高速缓存 SRAM(static random access memory)
- 高速缓存的局部性原理

####  储存设备
1. 存储器层次结构
- 寄存器 > L1高速缓存 > L2 > L3 > 主存(DRAM, 内存) > 本地二级存储 > 远程二级存储

####  操作系统管理硬件 
1. 抽象概念
- 进程 
    * 对正在运行的程序的一种抽象
    * 上下文切换 
    * 线程
- 虚拟内存 
    * 为每个进程提供一个假象, 即独占地使用主存
    * 每个进程看到的内存都是一致的, 称为虚拟地址空间

- 文件
    * 字节序列, 仅此而已
    * 向应用程序提供了一个统一的视图, 来看待系统中可能含有的所有各式各样的I/O设备

2. 内核
- 内核管理管理进程上下文的切换
- 内核是常驻主存的部分
- 内核不是一个独立的进程, 是系统管理全部进程所用代码和数据结构的集合

####  网络通信
1. 网络也是一种I/O设备
2. 通过网络适配器完成机器间的数据复制 

####  重要主题
1. Amdahl 定律
- 要想显著加速整个系统, 必须提升全系统中相当大的部分的速度 
- 描述了改善任何过程的一般原则
- 整体与部分的关系

2.  并发和并行
- 并发 (concurrency) 是一个通用的概念, 指一个同时具有多个活动的系统
- 并行(parallelism) 指的是用并发来使一个系统运行得更快
- 线程级并发
    * 在一个进程中执行多个控制流
    * 多核处理器
        * 每个核有各自的L1和L2高速缓存器, 共享更高层次的高速缓存
        * 从两个方面提高系统性能
        > 1. 减少了在执行多个任务时模拟并发的需要, (这里的模拟并发, 是分配时间片, 上下文切换的消耗么?)
        2. 可以使应用程序运行得更快, 前提是使用多线程编写
    * 超线程
        * 同时多线程(simultaneous multi-threading)
        * 一个CPU执行多个控制流的技术
- 指令级并行
    * 在较低层次的抽象上, 现代处理器同时执行多条指令
    * 超标量(super-scalar)处理器: 比一个周期一条指令更快的执行效率
    * 单指令, 多数据并行
3. 计算机系统中抽象的重要性
- 提供不同层次的抽象表示, 来隐藏实际实现的复杂性
- |- 虚拟机
    |- 操作系统
    |- 进程
        |- 指令集架构
            |- 处理器
        |- 虚拟内存
            |- 主存
            |- 文件 I/O设备

####  小结

## 2. 信息的表示与处理
#### 信息存储
1. 无符号数, 有符号数, 浮点数
- 溢出
- 补码
- 浮点运算是不可结合的 

2. 信息存储
- 虚拟内存上, 非常大的字节数
- 编译器和运行时系统将存储空间划分为更可管理的单元
- 程序对象: 程序数据, 指令, 控制信息 
- 可移植性的一个方面: 使程序对不同数据类型的确切大小不敏感

3. 寻址和字节顺序
- 大小端
- 最低有效字节, 从左向右开始, 指的就是数字的高低位

4. 布尔代数
- 与, 或, 非, 异或
- 信息论领域
- 布尔环, 长度为w的位向量上的 ^, & 和 ~ 运算时, 会得到一种不同的数学形式
    a & a = a;  a^a = 0;  0^b = b;
- 位向量运算, 分别将向量的每一位进行 与或非运算
- 位向量与集合的表示
    从右向左, 位向量为1的位置, 构成集合
- 掩码 
- 逻辑运算, 移位运算
    * 逻辑右移, 填充0
    * 算术右移, 按高位值填充
    * 左移都是填充0 
    * 约定有符号数都使用算术右移, 无符号数必须是逻辑右移
    * java中 >> 表示算术移位, >>> 表示逻辑移位

#### 整数表示
1. 无符号数编码的唯一性
- 双射
2. 补码编码
- 有符号数 使用 补码形式
- 补码编码的唯一性
    * 跟无符号数的编码一致, 但是高位为符号位
    * 正数的补码跟原码一致, 负数的补码还原, 符号位不变, 其余位取反加1, (这个还原也只是为了方便人工计算值, 机器计算还是直接用补码计算)
    * 这个性质就是在计算过程中发现的, 算不上推理(我比较倾向于推理的结果, 就是得到证明的结果, 而不是靠经验得出来的结果, 这个观念得改一改)
- 补码和反码

3. 有符号数和无符号数之间的转换
- C语言中不管数值信息, 保留位模式信息, 按强转的类型解释
- 补码转无符号数
- 无符号数转补码, 两个操作反过来
- 有符号数与无符号数比较, 默认先将有符号数转换成无符号数, 这样就会出现一些奇怪的现象
    负数比0大
- INT_MIN 和 INT_MAX
    * #define INT_MIN  (-INT_MAX - 1)

4. 扩展一个数字的位表示
- 无符号数的零扩展
- 补码数的符号扩展
- 截断无符号数 与 截断补码数值

5. 注意事项
- 比较, 数传运算, 避免使用无符号数
- 无符号数可做位的集合, 没有任何数字意义时, 比较好用, 用作mask 

#### 整数运算
1. 正溢出, 负溢出
2. 加, 乘
#### 浮点数
#### 小结
1. 数据表示后续有需求再研究

## 3. 程序的机器级表示
#### 历史观点
1. IA32, X86-64(X86), i386, i486, 
2. K(10^3), M(10^6), G(10^9)
#### 程序编码
1. 机器级代码 
- ISA(Instruction Set Architecture), 指令集架构
- 程序计数器(PC) %rip 给出要执行的下一条指令在内存中的地址
- C语言中的数据类型, 在机器代码中用一组连续的字节来表示, 不区分有无符号, 指针类型, 指针和整数
- x86-64的指令长度从1到15个字节不等, 常用的字节少, 不常用的字节多
- 反汇编器, 直接根据机器指令码序列来确定汇编代码, 与GCC编译出来的有差译, 但是不影响阅读
- ATT(AT&T) 与 Intel 汇编代码格式
    默认使用 ATT, Intel的编码代码比对学习, 多位操作数, 顺序不一致
- 

#### 数据格式
1.  汇编代码后缀
- 字节:b, 字:w, 双字:l, 四字:q, 单精度:s, 双精度:l
    双字和双精度都是l, 不会产生歧义, 因为机器指令和寄存器不同

#### 访问信息
1. 通用目的寄存器
- 16位(%ax-%bp), 32位(%eax-%ebp), 64位(%rax-%rbp, %r8-%r15)
2. 操作数指示符
- 立即数 ($), 寄存器(R[ra]), 内存引用(Mb[Addr])
- 寻址模式: 立即数(Imm), 寄存器(rb), 绝对, 间接, 基址+偏移量, 变址(Imm + R[rb] + R[ri]), 比例变址
- 数据传送指令: mov, 内存/寄存器 -> 寄存器, 目的大于源
    * 零扩展数据传送指令 zbw, zbl, zwl, zbq, zwq
    * 符号扩展数据传送指令 sbw, sbl, swl, sbq, slq, cltq

#### 算数和逻辑操作
#### 控制
#### 过程
#### 数组的分配和访问
#### 异数的数据结构
#### 在机器级程序中将控制与数据结合起来
#### 浮点代码
#### 小结

## 
#### 
#### 
#### 
#### 
#### 
#### 