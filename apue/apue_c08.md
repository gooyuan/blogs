
## 第八章 进程控制

### 学习记录

fork 函数也没有那么神秘, 可以直接调用, 本来就是嘛, 站在不同的层次, 做不同的事, 每个角色, 都是整个系统的一部分, 没必要特殊对待, 尽管是轻重之分.

最开始的印象真得影响很大, 最开始觉得难, 后续再次捡起来学的时候, 最开始的那种恐惧感还会影响到下意识, 下意识是畏难的.

士别三日将刮目相看, 这一道理不管是对别人, 还是对自己, 都是适用的, 训练降低第一印象的影响. 
我也已非吴下阿蒙, 所以, 学习的方式该有所改变, 也要时刻去提炼, 哪些是精华, 哪些是可以改进的. 

在linux内核情景分析看到的关于fork函数, 当时的感觉, 这是内核层的东西, 算是高级技术, 所以是难的, 轻易接触不到的, 那是因为站在的平台不一样, 这些最底层的抽象度可能高些, 但也不是高不可攀, 站在巨人的肩膀上, 肩膀以下只是少走了弯路, 同样也学会. 

进程标识

	pid, 实际用户id, 有效用户id, 组id, 有效组id, 父进程id

fork 

	返回两次, 父进程与子进程是并行运行的, 公共部分的代码是两个进程共同操控的, 但是变量值各自保持一份
	每fork一次, 进程增加一个, 这样来编写多线程是挺绕的. 

vfork

	vfork函数的调用序列和返回值与fork相同, 但是语义不同. 

	vfork 出来的子进程只是为了执行 exec 或 exit的, 在调用exec 或 exit之前, 子进程运行在父进程的地址空间里. 
	所以, 此时子进程如果有修改数据, 调用函数或没有调用exit或exec函数, 就返回都可能带来未知的结果. 

	这样又是如何提高效率的呢? 少复制了地址空间, 直接调用exec

	vfork的子进程会保证在父进程之前运行, 在调用exec或exit之后, 父进程才可能被调度运行

wait, waitpid

	wait 是个阻塞的函数, 所谓的阻塞, 就是过程实现, 汇编实现, 是将sip 指向子进程的代码, 执行完了再返回. 

竞争条件

	在多进程/线程访问共享数据或输出结果依赖于进程执行顺序时, 会产生竞争条件

exec 函数

	执行一个新函数只是替换了当前进程中的正文段, 数据段, 堆段和栈段.

修改用户id, 组id

	设置用户ID(set-user-ID), 有效用户ID(effective user ID), 实际用户id, uid, gid

	这几个概念, 当前登陆用户, 操作文件, 当前进程 都有 uid, gid, 

	login 时, 设置登陆用户的uid, gid, 称作实际用户id

	每个文件都有所有者, 这个所有者的id 与 文件设置位 共同决定进程操作文件时的有效id

	每个进程的id叫作有效id, 一般情况下是与实际id一致, 但是或文件的设置位打开时, exec打开程序会将有效id设置为程序文件所有者id, 达到临时提权的效果, 这也是passwd 程序可以改变系统passwd文件的机制. 
	root可以操作所有文件, 但是同可以设置文件的读写, 可执行位, 来保护文件, 如果root对于一个非w的文件写操作时, 也得先修改其w位.
	execve是内核程序, 有root权限. 

	一个文件的每个属性的每个位置含义
	drwxrwxrwx
	第一个属性 
		d : 目录, 
		`-` : 文件, 
		l : 链接, 
		b : 可随机存取装置, 
		c : 串行端口设备
		s : 数据接口文件
		p : 管道文件

	后面每三个一组, 第一组 代表所有者的读写可执行权限, 第二组代表所有组的读写可执行权限, 第三个代表其他用户的可操作权限. 
	每组第三位
		w : 可执行
		s : 可设置, 通过exec 执行时, 会将当前进程的有效id临时提权到程序文件所有者的id. 执行完恢复成实际用户的id, 只能应用在可执行程序文件上
		t : 粘滞位, 在程序执行完时, 告诉系统在内存(虚拟内存,非物理内存) 中保存一份备份, 常用的程序可以节省寻址时间, 只对目录有效, 该属性设置后, 只有目录所有者及root才可以删除此目录. 

解释器文件

```sh
	#! pathname [optional-argument]
```

	解释器文件是第一行以`#!`开头的文本文件, 解释器是`#!`后面绝对路径指向的可执行文件
	exec在执行解释器文件时, 会解析其解释器来执行此文件

system 

	可以通过sh -c 来将字符串解析成命令执行

进程会计
	
	对进程信息的统计, 可以写一个程序用来读account 信息. 
	可以再现进程的启动, 运行时间, uid, gid 的信息. 
	进程终止时产生一个会计记录, 这样对于永不中止的进程就没有记录, 且不能精确的获取进程启支的顺序.

用户标识
	
	一个用户可以有多个登陆名,  getpwuid(getuid()) 可以运行该程序时的登陆名 
	通过getlogin值获取用户登录时使用的名字

进程调度

	nice 值, 影响cpu占用的时间权重

僵死进程

	见练习题6

### 总结

进程标识, 进程控制, 控制原语函数: exec, fork, `_exit`, wait, waitpid

进程产生竞争条件, 并发的难题. 

### 习题与问题
1. 在图8-3程序中, 如果用exit调用代替_exit 调用, 那么可能会使标准输出关闭, 使printf 返回-1. 修改该程序以验证在你所使用的系统上是否会产生此种结果. 如果并非如此, 你怎样处理才能得到类似的结果呢? 

	在ubuntu 16.04上验证, exit(0), 并未让该进程的标准输出关闭

	在exit(1) 前使用fclose, 然后 使用sprintf, write 代替 printf输出

2. 回忆图7-6中典型的存储空间布局. 由于对应于每个函数调用的栈帧通常存储在栈中, 并且由于调用vfork后, 子进程运行在父进程的地址空间中,如果不是在main函数中而是在另一个函数中调用vfork, 此后子进程又从该函数返回, 将会发生什么? 请编写一段测试程序对此进行验证, 并且画图说明发生了什么? 

	会出现segmentation fault, 因为vfork 会返回两次, 第一次返回的时候, 调用栈帧已经弹出了, 第二次返回就找不到返回地址
	在函数里调用vfork, 连子进程的pid 与调用函数的pid 也不连续了. 
	即使将子进程exit掉, 返回vfork出来的子进程, 主进程还会报wait error: Success错误.

	这里可以推断出, 函数调用, 调用函数不是在当前线程执行? 为何子进程号不连续呢?  

	wait error 是哪里报出的呢? 调用函数还等待返回吗?

3. 重写8-6中的程序, 把wait 换成waiteid. 不调用pr_exit, 而从siginfo 结构中确定等价的信息. 

	siginfo 的结构要在第10章获取, 现在会出现 wait error

4. 当用$./a.out执行图8-13中的程序一次时, 其输出是正确的. 但是若将该程序按下列方式执行多次, 则其输出不正确. 
```shell
$ ./a.out; a.out; ./a.out
output from parent
ooutput from parent
ouotuptut from child
put from parent
output from child
utput form child 
```
原因是什么? 怎样才能更正此类错误? 如果使子进程首先输出, 还会发生此问题吗?

	父进程, 子进程的执行顺序不确定, 由内核调度. 
	实现WAIT_CHILD, TELL_CHILD等函数, 答案里并未实现, 先往前进吧, 暂时没有做这些题的欲望


5. 在图8-20所示的程序中, 调用execl, 指定pathname为解释器文件. 如果将其改为调用execlp, 指定testinterp 的filename, 并且如果目录/home/sar/bin 是路径前缀, 则运行该程序时, argv[2] 的打印输出是什么?

	对这些api的学习下意识里有些拒绝, 但是现在不学习这些api的使用, 还想什么时候学习呢? 最主要的还是学习的目的不明确, 不清楚

6. 编写一段程序创建一个僵死进程, 然后调用system执行ps(1)命令以验证该进程是僵死进程.

	什么是僵死进程, 子进程退出时, 父进程并未对其发出的SIGCHILD信号进行适当处理, 导致子进程留在僵死状态等待其父进程为其收尾, 这个状态下的子进程就是僵死进程. 
	Zombie 进程并不占用内存空间, 只是在进程表占用一个位置, 记载该进程的退出状态等信息供其他进程收集. 
	对SIGCHILD信号的处理就是wait函数, 或显示忽略该信号
	僵死进程 kill -9 也不可以杀除, 只能通过杀死其父进程, 僵死进程转成孤儿进程, 交由 init 进程清理

7. 8.10 节中提及POSIX.1 要求在exec时关闭打开目录流. 按下列方法对此进行验证: 对根目录调用opendir, 查看在你系统上实现的DIR结构, 然后打印执行时关闭标志. 接着打开同一目录读并执行时关闭标志. 

	DIR *opendir(const char *pathname);

