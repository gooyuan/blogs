
## realloc
- C的标准库, 要怎么系统的学习呢?
- 写3sum算法的时候, 只会 malloc, 所以, 动态分配与释放的时候, 搞不转了, 有了这个函数, 就容易得多
- calloc, malloc, realloc
    * 堆上配置的struct数组指针, 指向 函数内的struct对象, 会在函数执行完出栈的时候弹出吗?
    * 需要不需要每个struct指针所指对象也要在堆上分配一下?

## ++, --, while
- c 与 java 的编译规则不一样, 在3sum算法中试验出来的
- 看c reference 上描述的, 是一样的, 但是在 3sum上实践出来的并不一样
- while(nums[i] == nums[++i]); 这样实验出来的并不OK
    需要替换成:
    while(nums[i] == nums[i+1]){
        ++i;
    }
    ++i;
- 很迷惑人

## for 循环
- 双层for循环, 变量初始化的问题
- ++, -- 虽然对有些编译器表现不一样, 但是大致功能还是一样的
- 二维数组与 int** 这个还是有些区别, 如何将二维数组传入 int** 有待解决

## typedef
- type
    * 取一个别名
- struct
    * 在C++中当类处理, 与 typedef一起跟C的作用一样, struct <qualifier> 一起作为一个类型
- function
    * typedef <return type> <(*funcName)>(<argument...>)
- arry
    typdef baseType newType[arraySize] 
- pointer
    typedef int *Ptr;   
    Ptr p; <==>  int* p;

## 数组与指针
1. 二维数组
    > 二维
    > 二维指针与一维指针
        int **p 与 int *p

    >数组指针与指针数组 

        int *p[5] 与 int (*p)[5]
        
        int*p 与 int a[5],  // *p 可以指向一个单变量的地址， 也可以指向一个一维数组的地址, 
                            // 虽然指针可以指向数组， 但是sizeof(p), 为一个地址的大小, sizeof(a)是一个数组的大小
                            // 这都是编译器解释的不一样， 会将指针解释成间接寻址， 将数组解析成直接寻址

        int arr[5][5] = {0}; //不管是数组还是变量， 都得先初始化， 然后才可以使用指针操作

        int**p = &arr[0]; // p 是一个指向指针的地址的指针

        (int*p)[5] = arr;   // 这里的p 都是一个变量， 只有*p 代表的意义不一样
        
        int *p[5] // 指针数组， 是一组数组， 但是数组中的值又可以指针数组, 当然也可以指向数值
    > 数组和指针， 指针可以指向数组的地址， 但是针对sizeof, 编译器解释的就不同了， 数组一般都是连续的地址， 所以解释成内存块区域的大小， 而指针， 只是一个地址值的大小, 指针是间接寻址， 数组则可以直接寻址

2. Design Circular Queue
- 面向对象的思想太局限性了, 非得将struct看成一个类, 当成每个数据结点
- C 是可以实现面向对象的， 结构体只装指针， 实体数据存储， 要么是简单的基本数据类型， 堆上的数据， 也只是保存指针
- 由此可以理解 jni的数据通信
- 函数指针， 更是灵活的一批, 可以作回调， 还可以作为返回值, 作为返回值的应用场景

3. 动态内存
    - 二维数组 

        int** arr = (int**)malloc(100 * sizeof(int*))
   - 第二维的指针必须使用arr[i], 而不可以使用*(arr + i) 
   - 一天的时间， 主要学习二维数组的指针用法， 

# restrict

	类型限定符, 告诉编译器, 对象已被指针引用, 不能通过除该指针外所有其他直接或间接的方式修改该对象的内容. 

	c99 标准引入的, 

## 技巧积累

1. if 中赋值语句和逻辑比较, 赋值语句需要括号包起来, 再进行逻辑比较

	if((val = fcntl(fd, cmd, args) < 0)

2. 非零即真. 在无逻辑判断语句中

3. 

