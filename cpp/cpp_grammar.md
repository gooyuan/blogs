
## 背景
    以前有接触过c++, 但是完整的语法知识还是欠缺, 想借着学习openGL的机会学习cpp, 此文档对此opengl学习过程中关于cpp相关的学习记录下来

## 知识点
1. 指针
- 内存地址
- 指针与引用
- 赋值: 
    * 指针与类型变量之间的赋值: 值拷贝, 引用拷贝
    * 指针变量间赋值: 默认是赋值变量所存储的内容(所指变量的地址), 如果强迫取指针变量的地址&, 理论上被赋值变量的类型是int* 型, 是可以的, 人工将指针变成二级指针, 但是在编译器里还是一级指针的形式
- 二级,三级指针
    * 内存地址是 int 型的变量, 所以一级指针隐式的也可以存指针的地址, 这得人工来维护
    * 二级指针, 三级指针, 是将这个维护工作交给编译器来做, 将上述的人工约束实现成规范, 人为读代码更容易理解

2. .h .cpp
- 为了更好的接口编程而搞的一种源代码存储形式
- 更有效的保护了代码的具体实现, 阻碍不良企图之人找漏洞
- #ifndef, 重复定义, 重复导入的问题, 每个 .h文件都首尾都需要添加, 那为何编译器不直接默认都做这个检查呢
- .h 放声明, .cpp 实现
- cpp 中的实现, 需带类名, 有什么方法不带的呢? 每个实现都在带上类名, 感觉上重复太多, 直接放在一个类中, 岂不是更好看?
    当然, 都带上类名限定更直观
- .h .cpp 名字建议都与类名一致, 约定如此, 代码更容易维护, 当然可以不一致

3. static
- 静态全局变量, 所谓的全局也只是针对文件, c语言的文件也是作用域划分的一部分, 这跟脚本语言类似, c++ 当然也有这种特性, 但是, namespace是跨类解决作用域的问题, 其他文件可以有相同名字的变量不会发生冲突 
- 静态局部变量, 也是存在全局内存区(.data区), 但是不可被其他函数和文件访问, 每次访问的值会延用上一次的值
- 局部与全局, 只是在作用域上不一样, 内存分布和生命周期是一样的
- static函数, 私有成员函数, 这个功能使用.h 文件不也有这个功能, 不在.h文件里声明就可以做到
    加了static, 即使在.h中声明, 也不可被外界访问
- 主要作用是对外隐藏, 所有的变量和函数声明默认是 extern 的

4. c程序的内存分布
- 明白内存分布, 十分有必要, 与内存分布相关的关键字, 是编写有质量代码的关键
- 命令行参数和环境变量, 栈, 堆, .bss, .data, .text

5. 对象的使用
> Object obj; 与 Object obj = new Object();
- 这两种初始化方式, 什么时候可以使用哪一种