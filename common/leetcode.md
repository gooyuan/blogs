
## 说明
- leetcode 也刷了55道, 除掉easy 也还有20道
- 刷了终究是有用的, 后面再捡起来, 还是会接着以前的战绩 
- 有时间就刷吧, 现在先从medium开始刷, 以兔派方式刷
- 突破80道题， 说出去的话

### Container with most water
1. 这个算法, 今天一下子就搞明白了, 按水的流动来理解
2. 加深了暴力枚举的作用的认识

### 3sum
1. 跟container with most water 有类似的思想, 枚举是过不了关的
2. 还未通关, 去除重复有点麻烦

### power(x, n)
1. 递归与循环是可以互换的
2. 位运算
3. for循环是搞不定的

### remove k digits
1. 

### design circular queue
1. 

### cheapest flight within k stops
1. Dijkstra 
- 思路:
    1. 必须有一个起点, 初始化起点到各个城市的花费
    2. 将此城市可到达的城市都放在一个队列里待搜索
    3. 以队列中的城市为起点, 再次编历整个数组, 更新可到达城市的最小花费, 然后将可到达城市再次加入队列
    4. 临界条件, stops == K站的时候, 只比较可到达目的地的站点, 更新目的地的值, 此临界已经不会再向队列中加入城市, 所以是最后一次搜索
        * 问题: 在K站以内, 理论上直达要比多站买票便宜, 直达票在第一次比较中就已经初淘汰了, 怎么办
        * 直达票每有被淘汰, 而是优化更新在了目的地中, 等到中转到目的地, 再比较, 所以不会丢掉值 

- 贪心算法
- 图
    * 图有什么性质
    * 松弛操作

- BFS, DFS, BF
    * Broad First Search
    * Deep First Search
    * Binary Find
- Dijkstra 是复用了广度优先搜索, 优化版本是在缓冲 queue上, 有queue, priorityQueue, Fibonacci heap

2. Bellman
- 松弛操作
    * 实际上是对相邻节点的访问
    * 第n次松弛操作保证了所有尝试为n的路径最短, 由于图的最短路径不会超过 n-1, 可知算法没最短路径
- 负边权操作
- 负权环判定
    * 负权环可以无限制地降低总花费, 所以 发现第n次操作仍可降低花销, 就一定存在负权环
- 优化
    * 循环提前跳出, 当某次循环不再松弛时, 直接退出循环, 进入负权环的判定
    * 队列记录松弛过的点

### Traingle
1. 思路
- 广度优先搜索， 遍历出每一条路径的最小值
2. 实现
- 确实实现了， 还是需要调试信息才可， 直接记事本写代码， 人脑调试有些难度

### Perfect Squares
0. 描述

    给定一个正整数, 找到最少的平方数(1,4,9,16...)和的个数

        example：

        input: 13
        export: 2
        explain: 13 = 4 + 9
     
        input: 12
        export: 3
        explain: 12 = 4 + 4 + 4
- 思路
    1. 数学理论: Legendre's three-square theorem <br>
    一个整数可以分解成 4\*k(8\*m + 7)的形式， 就一定是4个完美平方数之和, 如果不能分解成， 再判断 n-i*i 是不是平方数， 如果是， 答案就2, 如果不是，答案就是3

    数学方法更高效， 也更难一些， 最主要的方法还是要学会计算机思维的算法， 才可能解决更普遍的问题
    2. 动态规划: 一直不得其法<br>
        特点: 下一步的决策依赖已经产生的结果，再具有纠错能力,就是回溯算法<br>
        有一个数组专门记录状态？迷宫问题也是如此, 所以迷宫也是DP问题<br>
        那又是如何得出来dp(n) = Min{dp[n - i*i] + 1} 的？ <br>
        一个数拆解为平方数的思路： 先找到范围内最大的平方数 i*i, 再拆解剩下的数, n - i*i, n - i*i在dp[] 中已经记录， 而 dp(1), dp(2), dp(3) 是显然已知的, 因此可得第n个数的完美平方数个数为 Min{dp[n - i*i] + 1}, 因此也可证明数学问题
    3. 广度优先搜索: Breadth-First Search

- 实现

## Valid Parethensis String
0. 描述
    给定一个字符串， 只包含三种字符 '(', ')', '*' <br>
    '*' 可以匹配空字符，'(', ')'， <br> 
    () 成对匹配， 字符串为true

    example:

        input: "()"
        output: "true"

        input: "(*"
        output: true

        input: "(*))"
        output: true

- 思路
    使用堆栈思想, 使用计数器模拟, 不用计'*', 同时讲左(右)

- 实现
    "(())((())()()(*)(*()(())())())()()((()())((()))(*"
    method 1: 一次循环能记录多条分支结果:
        '(': right++，需要等到循环结束， 查看left 是否为零，才能判断是否有分支满足
        '*': do nothing, 不用作判断
        ')': left--, 如果在实际的')'的匹配过程中，right < 0 了， 说明此分支终结
    method 2: 
        分别遍历两次， 先将 '*' 当成 '(' 处理, 如果此是时 balence == 0 ， 说明合法
        再将 '*' 当成')'处理， 最终结果是 bal == 0, 说明合法, 这个思想是将上面的实现拆分

## 后续直接转移到git/algorithm仓库下， 在代码中注释
